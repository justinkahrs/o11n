name: macOS release (manual signing)

on: pull_request         # run on every PR pushed to the repo

jobs:
  macos-build:
    runs-on: macos-latest
    strategy:
      matrix:
        target: [aarch64-apple-darwin]

    env:
      RUSTFLAGS: "-C target-cpu=native"

      # ——— signing cert & keychain ———
      APPLE_CERTIFICATE:            ${{ secrets.APPLE_CERTIFICATE }}
      APPLE_CERTIFICATE_PASSWORD:   ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
      KEYCHAIN_PASSWORD:            ${{ secrets.KEYCHAIN_PASSWORD }}      # any random string
      APPLE_SIGNING_IDENTITY:       ${{ secrets.APPLE_SIGNING_IDENTITY }} # either CN or SHA-1

      # ——— notarisation (ASC API key) ———
      APPLE_API_KEY_B64:            ${{ secrets.APPLE_P8_KEY }}
      APPLE_API_KEY_ID:             ${{ secrets.APPLE_API_KEY }}       
      
      GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY}}
      APPLE_API_ISSUER:             ${{ secrets.APPLE_API_ISSUER }}       # 8-4-4-4-12 UUID

    steps:
    - uses: actions/checkout@v4
      with: { fetch-depth: 0 }

    # ---------- toolchains ----------
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        profile: minimal
        toolchain: stable
        target: ${{ matrix.target }}
        override: true

    - name: Rust cache
      uses: swatinem/rust-cache@v2
      with:
        workspaces: './src-tauri -> target'
        cache-on-failure: true

    - name: Install Node
      uses: actions/setup-node@v4
      with:
        node-version: '22'
        cache: 'npm'

    - name: Install Tauri CLI globally
      run: npm install -g @tauri-apps/cli@1

    # ---------- JS deps ----------
    - run: npm ci

    # ---------- import certificate (hardened: no password prompt) ----------
    - name: Import Developer-ID / Apple-Distribution certificate
      run: |
        echo "$APPLE_CERTIFICATE" | base64 --decode > cert.p12

        # 0) create + unlock an isolated keychain
        security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
        security set-keychain-settings -lut 3600 build.keychain            # keep unlocked 1 h
        security unlock-keychain   -p "$KEYCHAIN_PASSWORD" build.keychain
        # put it first in the search path
        security list-keychains -d user -s build.keychain $(security list-keychains -d user | tr -d '"')

        # 1) import + pre-authorise the key for codesign/productbuild/notarytool
        security import cert.p12 -k build.keychain \
          -P "$APPLE_CERTIFICATE_PASSWORD" \
          -T /usr/bin/codesign \
          -T /usr/bin/productbuild \
          -T /usr/bin/xcrun \
          -T /usr/bin/security \
          -A                                         # allow all, or remove for stricter

        # 2) extra ACL for 10.15+
        security set-key-partition-list -S apple-tool:,apple:,codesign: \
          -s -k "$KEYCHAIN_PASSWORD" build.keychain

        security find-identity -v -p codesigning build.keychain | grep "$APPLE_SIGNING_IDENTITY"
      shell: bash

    # ---------- build & codesign ----------
    - name: Build Tauri bundle (signed)
      run: npm run tauri -- build --target ${{ matrix.target }}
      env:
        APPLE_SIGNING_IDENTITY:       ${{ secrets.APPLE_SIGNING_IDENTITY }}
        APPLE_CERTIFICATE:            ${{ secrets.APPLE_CERTIFICATE }}
        APPLE_CERTIFICATE_PASSWORD:   ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        TAURI_SIGNING_PRIVATE_KEY:    ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
        TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        CI: true                       # skips any CLI questions
      shell: bash

    # ---------- zip & notarise ----------
    - name: Zip the .app for notarisation
      run: |
        APP_NAME=$(jq -r '.productName' src-tauri/tauri.conf.json)

        # locate the real bundle path (works with or without target triple)
        APP_PATH=$(find src-tauri/target -type d -name "${APP_NAME}.app" | head -n1)
        if [[ -z "$APP_PATH" ]]; then
          echo "::error ::Could not locate ${APP_NAME}.app"
          exit 1
        fi

        ditto -c -k --keepParent "$APP_PATH" "${APP_NAME}.zip"

        echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV
        echo "APP_PATH=$APP_PATH" >> $GITHUB_ENV
      shell: bash

    - name: Restore ASC API key file
      run: echo "$APPLE_API_KEY_B64" | base64 --decode > "$HOME/AuthKey.p8"

    - name: Submit to Apple notarisation service
      run: |
        xcrun notarytool submit "$APP_NAME.zip" \
          --key "$HOME/AuthKey.p8" \
          --key-id "$APPLE_API_KEY_ID" \
          --issuer "$APPLE_API_ISSUER" \
          --wait
      shell: bash

    - name: Staple the ticket
      run: xcrun stapler staple -q "$APP_PATH"

    # ---------- release artefacts ----------
    - name: Collect DMG + ZIP for release
      run: |
        mkdir -p dist
        cp -v src-tauri/target/*/release/bundle/dmg/*.dmg dist/
        mv -v "$APP_NAME.zip" dist/
      shell: bash

    - name: Create .app tarball
      id: make_tar
      shell: bash
      run: |
        APP_NAME=$(jq -r '.productName' src-tauri/tauri.conf.json)
        APP_PATH=$(find src-tauri/target/*/release/bundle -type d -name "${APP_NAME}.app")
        VERSION=$(jq -r '.version' package.json)
        RAW_ARCH=${{ matrix.target }}
        ARCH=$(echo "$RAW_ARCH" | tr '[:upper:]-' '[:lower:]_')
        TAR_NAME="o11n_${VERSION}_${ARCH}.app.tar.gz"

        mkdir -p dist
        tar czf dist/"${TAR_NAME}" -C "$(dirname "$APP_PATH")" "$(basename "$APP_PATH")"

        echo "tar_name=${TAR_NAME}" >> $GITHUB_OUTPUT
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "arch=${ARCH}"     >> $GITHUB_OUTPUT

    - name: Import GPG signing key
      if: ${{ secrets.GPG_PRIVATE_KEY != '' }}
      shell: bash
      run: echo "$GPG_PRIVATE_KEY" | gpg --batch --import

    - name: Sign the tarball
      shell: bash
      run: |
        gpg --batch --yes --armor \
          --detach-sign \
          --output dist/"${{ steps.make_tar.outputs.tar_name }}".sig \
          dist/"${{ steps.make_tar.outputs.tar_name }}"

    - name: Create latest.json
      shell: bash
      run: |
        TAG=${GITHUB_REF##*/}
        BASE_URL="https://github.com/${{ github.repository }}/releases/download/${TAG}"
        cat > dist/latest.json <<EOF
        {
          "version": "${{ steps.make_tar.outputs.version }}",
          "files": {
            "${{ steps.make_tar.outputs.arch }}": {
              "url": "${BASE_URL}/o11n_${{ steps.make_tar.outputs.version }}_${{ steps.make_tar.outputs.arch }}.app.tar.gz",
              "sig": "${BASE_URL}/o11n_${{ steps.make_tar.outputs.version }}_${{ steps.make_tar.outputs.arch }}.app.tar.gz.sig"
            }
          }
        }
        EOF

    - name: Draft GitHub Release with artifacts
      uses: softprops/action-gh-release@v2
      with:
        draft:    true
        tag_name: ${{ github.ref_name }}
        files:    dist/*

    # ---------- clean up ----------
    - name: Delete temporary keychain
      if: always()
      run: security delete-keychain build.keychain